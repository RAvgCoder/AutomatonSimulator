use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use crate::automaton_graph::{State, Symbol};
use crate::dfa::dfa_reduction::dfa_step_renderer::table::Table;
use crate::dfa::dfa_reduction::{EquivalenceClass, Steps};
use crate::dfa::DFA;

const PADDING_SIZE: usize = 7;

/// Holds steps to Displays a step-by-step solution for reducing a dfa
#[derive(Debug)]
pub struct DFAReductionStepsRenderer<'a> {
    table_steps: Table,
    steps: Steps,
    state_transition_map: &'a HashMap<String, Vec<String>>,
    transitions_alphabets: Vec<Symbol>,
    reduction_was_successful: bool,
    class_name_dividing: String,
    step_count: u32,
}

impl<'a> DFAReductionStepsRenderer<'a> {
    /// Creates a renderer for showing the steps taken by a dfa reducer
    ///
    /// # Arguments
    ///
    /// * `state_transition_map`: A map of all states and a list of states they transition to
    /// * `final_and_non_final_classes`: An equivalence class which was divided into final and non-final states
    /// * `state`: Any state in the dfa. Used for finding the transition alphabets (Î£)
    pub fn new(
        state_transition_map: &'a HashMap<String, Vec<String>>,
        final_and_non_final_classes: &Vec<EquivalenceClass>,
        state: &Rc<State>,
    ) -> DFAReductionStepsRenderer<'a> {
        let err_message = "First division was not properly split into final and no final states";
        assert!(final_and_non_final_classes.len() <= 2, "{}", err_message);

        let first_class = EquivalenceClass::create_name(EquivalenceClass::get_start_count());
        final_and_non_final_classes
            .iter()
            .find(|equivalence_class| *equivalence_class.prefix_name() == first_class)
            .expect(err_message);

        let split_table =
            Self::render_table_to_string(None, final_and_non_final_classes, state_transition_map);

        let transition_alphabets = state
            .get_transitions()
            .iter()
            .map(|transition| transition.transition_on())
            .collect::<Vec<Symbol>>();

        DFAReductionStepsRenderer {
            table_steps: Table::new(vec![split_table.clone()], &transition_alphabets),
            steps: Steps::new(vec![
                String::from("Divide the table into final, 'C0' and non-final 'C1' states"),
                split_table,
            ]),
            state_transition_map,
            transitions_alphabets: transition_alphabets,
            reduction_was_successful: false,
            class_name_dividing: String::new(),
            step_count: 1,
        }
    }

    /// Moves the tables generated by reduction out of the renderer
    pub fn move_table_steps(&mut self) -> Table {
        std::mem::take(&mut self.table_steps)
    }

    /// Moves the instructions for steps taken for reduction created out of the renderer
    pub fn move_steps(&mut self) -> Steps {
        std::mem::take(&mut self.steps)
    }

    pub fn transitions_alphabets(&self) -> &Vec<Symbol> {
        &self.transitions_alphabets
    }

    /// Show how tha class was broken down into smaller classes
    ///
    /// Add the new table after new equivalence class has been created to the table list
    ///
    /// # Arguments
    ///
    /// * `new_split_classes`: A slice containing the new classes that were created from the division
    /// * `complete_equiv_class_list`: A complete equivalence class list
    pub fn add_split_classes(
        &mut self,
        new_split_classes: &[EquivalenceClass],
        complete_equiv_class_list: &Vec<EquivalenceClass>,
    ) {
        // Alerts the renderer that reduction was successfully completed
        self.reduction_was_successful = true;

        // Tell us what states it was broken into Eg: C1, C2
        let new_class_names =
            new_split_classes
                .iter()
                .enumerate()
                .fold(String::new(), |mut acc, (idx, classes)| {
                    acc.push_str(classes.prefix_name());
                    if idx < new_split_classes.len() - 1 {
                        acc.push_str(", ");
                    }
                    acc
                });
        self.steps.push(format!(
            "Since all states in {} dont fall into the same equivalence class it is then split into [{}]",
            self.class_name_dividing,
            new_class_names
        ));
        // Show the new tables that are created
        self.steps.push(String::from("These include:"));
        self.steps.push(Self::render_table_to_string(
            Some(new_split_classes),
            complete_equiv_class_list,
            self.state_transition_map,
        ));

        // Add a new iteration to the tale
        self.table_steps.push(Self::render_table_to_string(
            None,
            complete_equiv_class_list,
            self.state_transition_map,
        ))
    }

    /// Adds a comment on the progress after checking if a state could be reduced
    pub fn split_conclusion(&mut self) {
        self.steps.push(if !self.reduction_was_successful {
            format!(
                "Could not split {} as all state transitions fall into the same equivalent classes", self.class_name_dividing
            )
        } else {
            format!("Since splitting {} was successful we have to re-evaluate all classes again to see if any have changed", self.class_name_dividing)
        });
        self.steps.push(String::new());
    }

    /// Adds the name of the class that is being checked for subdivision
    ///
    /// # Arguments
    ///
    /// * `class_dividing`: The class to be checked for subdivision
    pub fn add_name_of_sub_dividing_class(&mut self, class_dividing: &EquivalenceClass) {
        self.steps.push(format!("Step {}:", self.step_count));
        self.step_count += 1;
        self.steps.push(format!(
            "We now pick and try to subdivide the equivalence classes {}",
            class_dividing.prefix_name()
        ));

        // Reset the reduction checking
        self.reduction_was_successful = false;
        self.class_name_dividing = class_dividing.prefix_name().clone()
    }

    /// Adds closing remarks to the steps
    pub fn finish(&mut self, eq_list: &Vec<EquivalenceClass>) {
        self.steps.push(format!(
            "All states are now reduced into their equivalent classes giving us a total of {} equivalent classes",
            eq_list.len()
        ))
    }

    /// Retrieves the last table generated
    pub fn last_generated_table(&self) -> Option<&String> {
        self.table_steps.final_table()
    }

    /// Tracks states in a class currently being subdivided
    ///
    /// # Arguments
    ///
    /// * `state_id`: A state in a subdividing class
    /// * `class_transition_names`: Names of the classes corresponding to the states in its transitions
    pub fn track_sub_divisions(&mut self, state_id: &str, class_transition_names: &str) {
        self.steps.push(format!(
            "{: <padding$}|   {}",
            state_id,
            class_transition_names,
            padding = PADDING_SIZE
        ));
    }

    /// Generates a table from a partial_equivalence class if provided else it defaults to
    /// generating a full tale for all classes
    ///
    /// # Example of a table
    ///
    /// |--------------
    ///
    /// |     Class_Name
    ///
    /// |--------------
    ///
    /// |start  | C0 C0
    ///
    /// |s3     | C0 C0
    ///
    /// # Arguments
    ///
    /// * `partial_equivalence_classes`: A slice of the equivalence class you want to generate a table for
    /// * `full_equivalence_classes`: A list of all equivalence classes
    /// * `state_transition_map`: A map of all states and a list of states they transition to
    fn render_table_to_string(
        partial_equivalence_classes: Option<&[EquivalenceClass]>,
        full_equivalence_classes: &Vec<EquivalenceClass>,
        state_transition_map: &HashMap<String, Vec<String>>,
    ) -> String {
        let mut table = String::new();
        // Chose the class list to use
        let class_list_iterating = partial_equivalence_classes.unwrap_or(full_equivalence_classes);
        // Generate the table
        for equivalence_class in class_list_iterating {
            Self::render_class_name(&mut table, equivalence_class);

            Self::render_state_names_and_transition_classes(
                full_equivalence_classes,
                state_transition_map,
                &mut table,
                equivalence_class,
            );
        }

        // Return the table created
        table
    }

    /// Renders a class name in this format
    ///
    /// |--------------------
    ///
    /// |        ClassName
    ///
    /// |--------------------
    ///
    /// # Arguments
    ///
    /// * `renderer_buffer`: A string reference to render into
    /// * `equivalence_class`: The class for whose name you would want to render
    fn render_class_name(renderer_buffer: &mut String, equivalence_class: &EquivalenceClass) {
        let line_separator = "-".repeat(PADDING_SIZE * 2);
        renderer_buffer.push_str(&format!("|{}", line_separator));
        renderer_buffer.push('\n');
        renderer_buffer.push_str(&format!(
            "|{name: >padding$}",
            name = equivalence_class.prefix_name(),
            padding = PADDING_SIZE
        ));
        renderer_buffer.push('\n');
        renderer_buffer.push_str(&format!("|{}", line_separator));
        renderer_buffer.push('\n');
    }

    /// Renders a list of transition state names in a class to equivalent class name of each transition
    ///
    /// |start| C0 C0
    ///
    ///  |s3  | C0 C0
    ///
    ///  |s1  | C1 C1
    ///
    ///  |s0  | C1 C1
    ///
    /// # Arguments
    ///
    /// * `equivalence_classes`: This `must` contain a list of all equivalence classes
    /// * `state_transition_map`: A map of all states and a list of states they transition to
    /// * `renderer_buffer`: A string you would render the transitions into
    /// * `equivalence_class`: The equivalence class for which you would render transitions
    fn render_state_names_and_transition_classes(
        equivalence_classes: &Vec<EquivalenceClass>,
        state_transition_map: &HashMap<String, Vec<String>>,
        renderer_buffer: &mut String,
        equivalence_class: &EquivalenceClass,
    ) {
        for class_state_id in equivalence_class.state_ids() {
            let connecting_points = DFA::find_class_for_transitions(
                state_transition_map,
                equivalence_classes,
                class_state_id,
            );

            renderer_buffer.push_str(&format!(
                "|{: <padding$}| {}",
                class_state_id,
                connecting_points,
                padding = PADDING_SIZE
            ));
            renderer_buffer.push('\n');
        }
    }
}

impl<'a> Display for DFAReductionStepsRenderer<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{}", self.steps)?;
        writeln!(f, "\n")?;
        writeln!(f, "{}", self.table_steps)?;

        Ok(())
    }
}

pub mod steps {
    use std::fmt::{Display, Formatter};

    #[derive(Debug, Default)]
    pub struct Steps(Vec<String>);

    impl Display for Steps {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            writeln!(
                f,
                r#"----------------------------------
Solution Provided by the solver
----------------------------------"#
            )?;
            for step in &self.0 {
                writeln!(f, "{}", step)?;
            }

            Ok(())
        }
    }

    impl Steps {
        pub fn new(steps: Vec<String>) -> Steps {
            Steps(steps)
        }
        pub fn push(&mut self, step: String) {
            self.0.push(step)
        }
    }
}

pub mod table {
    use std::fmt::{Display, Formatter};

    use crate::automaton_graph::Symbol;
    use crate::dfa::dfa_reduction::dfa_step_renderer::PADDING_SIZE;

    #[derive(Debug, Default)]
    pub struct Table {
        table: Vec<String>,
        transitions_alphabets: String,
    }

    impl Display for Table {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            writeln!(
                f,
                "Class names are shown in order of transition alphabet names: [{}]",
                self.transitions_alphabets
            )?;

            writeln!(f, "Tables generated from reduction are")?;
            let spacing = "-".repeat(PADDING_SIZE * 4);
            for (iter_count, table) in self.table.iter().enumerate() {
                writeln!(f, "{}", spacing)?;
                writeln!(f, "Iteration count {}:\n{}", iter_count + 1, table)?;
            }
            writeln!(f, "{}", spacing)?;

            Ok(())
        }
    }

    impl Table {
        pub fn new(table: Vec<String>, transitions_alphabets: &Vec<Symbol>) -> Table {
            Table {
                table,
                transitions_alphabets: transitions_alphabets
                    .iter()
                    .map(|symbol| format!("{}", symbol))
                    .collect::<Vec<String>>()
                    .join(", "),
            }
        }

        pub fn push(&mut self, table: String) {
            self.table.push(table)
        }

        pub fn final_table(&self) -> Option<&String> {
            self.table.last()
        }
    }
}
