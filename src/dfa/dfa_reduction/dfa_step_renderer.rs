use std::collections::HashMap;
use std::rc::Rc;

use crate::automaton_graph::{State, Symbol};
use crate::dfa::dfa_reduction::EquivalenceClass;
use crate::dfa::DFA;

const PADDING_SIZE: usize = 7;

/// Holds steps to Displays a step-by-step solution for reducing a dfa
#[derive(Debug)]
pub struct DFAReductionStepsRenderer<'a> {
    table_steps: Vec<String>,
    steps: Vec<String>,
    state_transition_map: &'a HashMap<String, Vec<String>>,
    transitions_alphabets: Vec<Symbol>,
    reduction_was_successful: bool,
    class_name_dividing: String,
    step_count: u32,
}

impl<'a> DFAReductionStepsRenderer<'a> {
    /// Creates a renderer for showing the steps taken by a dfa reducer
    ///
    /// # Arguments
    ///
    /// * `state_transition_map`: A map of all states and a list of states they transition to
    /// * `final_and_non_final_classes`: An equivalence class which was divided into final and non-final states
    /// * `state`: Any state in the dfa. Used for finding the transition alphabets (Î£)

    pub fn new(
        state_transition_map: &'a HashMap<String, Vec<String>>,
        final_and_non_final_classes: &Vec<EquivalenceClass>,
        state: &Rc<State>,
    ) -> DFAReductionStepsRenderer<'a> {
        let err_message = "First division was not properly split into final and no final states";
        assert!(final_and_non_final_classes.len() <= 2, "{}", err_message);

        let first_class = EquivalenceClass::get_name(EquivalenceClass::get_start_count());
        final_and_non_final_classes
            .iter()
            .find(|equivalence_class| *equivalence_class.prefix_name() == first_class)
            .expect(err_message);

        DFAReductionStepsRenderer {
            table_steps: vec![Self::create_table_as_string(
                None,
                final_and_non_final_classes,
                state_transition_map,
            )],
            steps: vec![],
            state_transition_map,
            transitions_alphabets: state
                .get_transitions()
                .iter()
                .map(|transition| transition.transition_on())
                .collect::<Vec<Symbol>>(),
            reduction_was_successful: false,
            class_name_dividing: String::new(),
            step_count: 1,
        }
    }

    /// Moves the tables generated by reduction out of the renderer
    pub fn move_table_steps(&mut self) -> Vec<String> {
        std::mem::take(&mut self.table_steps)
    }

    /// Moves the instructions for steps taken for reduction created out of the renderer
    pub fn move_steps(&mut self) -> Vec<String> {
        std::mem::take(&mut self.steps)
    }

    /// Show how tha class was broken down into smaller classes
    ///
    /// Add the new table after new equivalence class has been created to the table list
    ///
    /// # Arguments
    ///
    /// * `new_split_classes`: A slice containing the new classes that were created from the division
    /// * `complete_equiv_class_list`: A complete equivalence class list
    pub fn add_split_classes(
        &mut self,
        new_split_classes: &[EquivalenceClass],
        complete_equiv_class_list: &Vec<EquivalenceClass>,
    ) {
        // Alerts the renderer that reduction was successfully completed
        self.reduction_was_successful = true;

        // Tell us what states it was broken into Eg: C1, C2
        let new_class_names =
            new_split_classes
                .iter()
                .enumerate()
                .fold(String::new(), |mut acc, (idx, classes)| {
                    acc.push_str(classes.prefix_name());
                    if idx < new_split_classes.len() - 1 {
                        acc.push_str(", ");
                    }
                    acc
                });
        self.steps.push(format!(
            "Since all states in {} dont fall into the same equivalence class it is then split into [{}]",
            self.class_name_dividing,
            new_class_names
        ));
        // Show the new tables that are created
        self.steps.push(String::from("These include:"));
        self.steps.push(Self::create_table_as_string(
            Some(new_split_classes),
            complete_equiv_class_list,
            self.state_transition_map,
        ));

        // Add a new iteration to the tale
        self.table_steps.push(Self::create_table_as_string(
            None,
            complete_equiv_class_list,
            self.state_transition_map,
        ))
    }

    /// Adds a comment on the progress after checking if a state could be reduced
    pub fn split_conclusion(&mut self) {
        self.steps.push(if !self.reduction_was_successful {
            format!(
                "Could not split {} as all state transitions fall into the same equivalent classes", self.class_name_dividing
            )
        } else {
            format!("Since splitting {} was successful we have to re-evaluate all classes again to see if any have changed", self.class_name_dividing)
        });
        self.steps.push(String::new());
    }

    /// Adds the name of the class that is being checked for subdivision
    ///
    /// # Arguments
    ///
    /// * `class_dividing`: The class to be checked for subdivision
    pub fn add_name_of_sub_dividing_class(&mut self, class_dividing: &EquivalenceClass) {
        self.steps.push(format!("Step {}:", self.step_count));
        self.step_count += 1;
        self.steps.push(format!(
            "We now pick and try to subdivide the equivalence classes {}",
            class_dividing.prefix_name()
        ));

        // Reset the reduction checking
        self.reduction_was_successful = false;
        self.class_name_dividing = class_dividing.prefix_name().clone()
    }

    /// Retrieves the last table generated
    pub fn last_generated_table(&self) -> Option<&String> {
        self.table_steps.last()
    }

    /// Tracks states in a class currently being subdivided
    ///
    /// # Arguments
    ///
    /// * `state_id`: A state in a subdividing class
    /// * `class_transition_names`: Names of the classes corresponding to the states in its transitions
    pub fn track_sub_divisions(&mut self, state_id: &String, class_transition_names: &String) {
        self.steps.push(format!(
            "{: <padding$}|   {}",
            state_id,
            class_transition_names,
            padding = PADDING_SIZE
        ));
    }

    /// Generates a table from a partial_equivalence class if provided else it defaults to
    /// generating a full tale for all classes
    ///
    /// # Example of a table
    ///
    /// |--------------
    ///
    /// |     Class_Name
    ///
    /// |--------------
    ///
    /// |start  | C0 C0
    ///
    /// |s3     | C0 C0
    ///
    /// # Arguments
    ///
    /// * `partial_equivalence_classes`: A slice of the equivalence class you want to generate a table for
    /// * `full_equivalence_classes`: A list of all equivalence classes
    /// * `state_transition_map`: A map of all states and a list of states they transition to
    fn create_table_as_string(
        partial_equivalence_classes: Option<&[EquivalenceClass]>,
        full_equivalence_classes: &Vec<EquivalenceClass>,
        state_transition_map: &HashMap<String, Vec<String>>,
    ) -> String {
        let mut table = String::new();
        // Chose the class list to use
        let class_list_iterating = partial_equivalence_classes.unwrap_or(full_equivalence_classes);
        // Generate the table
        for equivalence_class in class_list_iterating {
            Self::render_class_name(&mut table, equivalence_class);

            Self::render_state_names_and_transition_classes(
                full_equivalence_classes,
                state_transition_map,
                &mut table,
                equivalence_class,
            );
        }

        // Return the table created
        table
    }

    /// Renders a class name in this format
    ///
    /// |--------------------
    ///
    /// |        ClassName
    ///
    /// |--------------------
    ///
    /// # Arguments
    ///
    /// * `renderer_buffer`: A string reference to render into
    /// * `equivalence_class`: The class for whose name you would want to render
    fn render_class_name(renderer_buffer: &mut String, equivalence_class: &EquivalenceClass) {
        let line_separator = "-".repeat(PADDING_SIZE * 2);
        renderer_buffer.push_str(&format!("|{}", line_separator));
        renderer_buffer.push('\n');
        renderer_buffer.push_str(&format!(
            "|{name: >padding$}",
            name = equivalence_class.prefix_name(),
            padding = PADDING_SIZE
        ));
        renderer_buffer.push('\n');
        renderer_buffer.push_str(&format!("|{}", line_separator));
        renderer_buffer.push('\n');
    }

    /// Renders a list of transition state names in a class to equivalent class name of each transition
    ///
    /// |start| C0 C0
    ///
    ///  |s3  | C0 C0
    ///
    ///  |s1  | C1 C1
    ///
    ///  |s0  | C1 C1
    ///
    /// # Arguments
    ///
    /// * `equivalence_classes`: This `must` contain a list of all equivalence classes
    /// * `state_transition_map`: A map of all states and a list of states they transition to
    /// * `renderer_buffer`: A string you would render the transitions into
    /// * `equivalence_class`: The equivalence class for which you would render transitions
    fn render_state_names_and_transition_classes(
        equivalence_classes: &Vec<EquivalenceClass>,
        state_transition_map: &HashMap<String, Vec<String>>,
        renderer_buffer: &mut String,
        equivalence_class: &EquivalenceClass,
    ) {
        for class_state_id in equivalence_class.state_ids() {
            let connecting_points = DFA::find_class_for_transitions(
                state_transition_map,
                equivalence_classes,
                class_state_id,
            );

            renderer_buffer.push_str(&format!(
                "|{: <padding$}| {}",
                class_state_id,
                connecting_points,
                padding = PADDING_SIZE
            ));
            renderer_buffer.push('\n');
        }
    }
}

impl<'a> std::fmt::Display for DFAReductionStepsRenderer<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Steps for reducing the dfa are as follows:")?;
        for step in &self.steps {
            writeln!(f, "{}", step)?;
        }

        writeln!(f, "\n")?;
        write!(f, "Class names are shown in order of connection names: [")?;
        for (idx, symbol) in self.transitions_alphabets.iter().enumerate() {
            write!(f, "{}", symbol)?;
            if !(idx == self.transitions_alphabets.len() - 1) {
                write!(f, ", ")?;
            }
        }
        write!(f, "]\n")?;
        writeln!(f, "Tables generated from reduction are")?;
        let spacing = "-".repeat(PADDING_SIZE * 4);
        for (iter_count, table) in self.table_steps.iter().enumerate() {
            writeln!(f, "{}", spacing)?;
            writeln!(f, "Iteration count {}:\n{}", iter_count + 1, table)?;
        }
        writeln!(f, "{}", spacing)?;

        Ok(())
    }
}
